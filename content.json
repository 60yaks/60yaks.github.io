{"meta":{"title":"60 Yaks","subtitle":"Talking about making games.","description":"60 Yaks Per Second","author":"60 Yaks","url":"http://60yaks.com"},"pages":[{"title":"Categories","date":"2018-06-01T15:38:09.656Z","updated":"2018-06-01T15:38:09.655Z","comments":false,"path":"categories/index.html","permalink":"http://60yaks.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-23T03:00:43.692Z","updated":"2018-05-23T03:00:43.692Z","comments":false,"path":"tags/index.html","permalink":"http://60yaks.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Single Fire Components","slug":"Single-Fire-Components","date":"2018-06-03T09:18:10.000Z","updated":"2018-06-03T09:18:24.323Z","comments":true,"path":"Design-Patterns/ECS/Single-Fire-Components/","link":"","permalink":"http://60yaks.com/Design-Patterns/ECS/Single-Fire-Components/","excerpt":"Since using Entity Component System architecture for game design I’ve noticed a number of common patterns that are useful for solving different types of problems the “ECS” way. In this article I want to talk about what I’m calling the Single Fire Component pattern.","text":"Since using Entity Component System architecture for game design I’ve noticed a number of common patterns that are useful for solving different types of problems the “ECS” way. In this article I want to talk about what I’m calling the Single Fire Component pattern.Here’s a scenario. Your character is walking around the screen and they enter a trigger. In an ECS world how do you deal with this?The answer is to provide a mechanism so that when the entity (the character) enters the trigger, a single use component is added to that entity. Then a system that is watching for that component fires, and at the end of that update that system (or a dedicated cleanup system) takes that component off the entity.Components don’t always need to contain data. Sometimes they can just act as flags for a system to either respond to, or ignore, a given entity. In this case we want to use the component as a positive flag so the system knows when to act on an entity.Photo by Paul GilmoreTeleport SystemLet’s go through an example. In the game I’m working on I needed a way to teleport things once they entered a trigger. The teleport is triggered from a collision, and moves the position of the entity to a fixed point.Adding the componentFirst, I need a way to add the component to the entity on a trigger. This is done with a MonoBehaviour as right now there’s no pure ECS way to use physics or colliders.[Serializable] public struct Transition : IComponentData { public float2 Location; } [RequireComponent(typeof(Collider2D))] public class AddTransitionComponentOnTrigger : MonoBehaviour { // The location to set the transform too. [SerializeField] private Transform location; void OnTriggerEnter2D(Collider2D collider) { // Get the entity part of the object that collided with the trigger. var entityComponent = collider.gameObject.GetComponent&lt;GameObjectEntity>(); // Add the component to the entity. entityComponent.EntityManager.AddComponentData(entityComponent.Entity, new Transition { Location = new float2(location.position.x, location.position.y) }); } } Using the componentNow that the entity has a component added to it, a system can take over and perform some task. In our case we want the system to update the entities position based on the data in the Transition component.[UpdateAfter(typeof(MoveForward2DSystem))] public class TransitionSystem : JobComponentSystem { } First, we want the system to copy the Transition data from the component to the Position2D of the entity.[ComputeJobOptimization] struct CopyTransition : IJobProcessComponentData&lt;Transition, Position2D> { public void Execute( [ReadOnly]ref Transition transition, ref Position2D position) => position = new Position2D { Value = transition.Location }; } Then, we want to remove the Transition component from the entity.struct RemoveTransition : IJob { [ReadOnly] public EntityArray entities; public EntityCommandBuffer entityCommandBuffer; public void Execute() { for (int i = 0; i &lt; entities.Length; i++) entityCommandBuffer.RemoveComponent&lt;Transition>(entities[i]); } } Why do we need to use a command buffer to remove the component? When you’re in a job, you can’t access the entity manager, so you cannot remove a component using that. A job must use an EntityCommandBuffer to remove the component instead.And now we schedule those jobs in the TransitionSystem.[UpdateAfter(typeof(MoveForward2DSystem))] public class TransitionSystem : JobComponentSystem { [ComputeJobOptimization] struct CopyTransition : IJobProcessComponentData&lt;Transition, Position2D> { ... } struct RemoveTransition : IJob { ... } EndFrameBarrier endFrameBarrier; ComponentGroup componentGroup; protected override void OnCreateManager(int capacity) { endFrameBarrier = World.GetOrCreateManager&lt;EndFrameBarrier>(); componentGroup = GetComponentGroup( ComponentType.ReadOnly(typeof(Transition)), typeof(Position2D)); } protected override JobHandle OnUpdate(JobHandle inputDeps) { var entities = componentGroup.GetEntityArray(); var copyTransitionJob = new CopyTransition(); var copyTransitionJobHandle = copyTransitionJob.Schedule(this); var removeComponentsJob = new RemoveTransition { entities = entities, entityCommandBuffer = endFrameBarrier.CreateCommandBuffer() }; var removeComponentsJobHandle = removeComponentsJob.Schedule(copyTransitionJobHandle); return removeComponentsJobHandle; } } Notice how the CopyTransition job is chained to the RemoveTransition job so they run in that order.Photo by nibras al-riyamiExtracting the patternThis single-fire idea seems useful. So let’s take our system and make it resuable.public abstract class SingleFireSystem&lt;TComponent, TBarrier> : JobComponentSystem where TComponent : IComponentData where TBarrier : BarrierSystem { struct RemoveComponentJob : IJob { [ReadOnly] public EntityArray entities; public EntityCommandBuffer entityCommandBuffer; public void Execute() { for (int i = 0; i &lt; entities.Length; i++) entityCommandBuffer.RemoveComponent&lt;TComponent>(entities[i]); } } protected ComponentGroup group; protected BarrierSystem barrier; protected abstract JobHandle CreateJobHandle(JobHandle inputDeps); protected override void OnCreateManager(int capacity) { barrier = World.GetOrCreateManager&lt;TBarrier>(); group = GetComponentGroup(ComponentType.ReadOnly(typeof(TComponent))); } protected override JobHandle OnUpdate(JobHandle inputDeps) { var jobHandle = CreateJobHandle(inputDeps); var removeJob = new RemoveComponentJob { entities = group.GetEntityArray(), entityCommandBuffer = barrier.CreateCommandBuffer() }; var removeJobHandle = removeJob.Schedule(jobHandle); return removeJobHandle; } } And now we can reuse this to create single-fire systems.[UpdateAfter(typeof(MoveForward2DSystem))] public class TransitionSystem : SingleFireSystem&lt;Transition, EndFrameBarrier> { [ComputeJobOptimization] struct CopyTransition : IJobProcessComponentData&lt;Transition, Position2D> { public void Execute( [ReadOnly]ref Transition transition, ref Position2D position) => position = new Position2D { Value = transition.Location }; } protected override JobHandle CreateJobHandle(JobHandle inputDeps) { var job = new CopyTransition(); return job.Schedule(this, inputDeps); } } ConclusionNow we’ve got a reusable system for handling tasks when we need something that only works for one update. A useful system for triggers, or collisions, etc.","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://60yaks.com/categories/Design-Patterns/"},{"name":"ECS","slug":"Design-Patterns/ECS","permalink":"http://60yaks.com/categories/Design-Patterns/ECS/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://60yaks.com/tags/Design-Patterns/"},{"name":"ECS","slug":"ECS","permalink":"http://60yaks.com/tags/ECS/"}]},{"title":"Starting the Blog","slug":"Starting-the-Blog","date":"2018-05-13T16:00:00.000Z","updated":"2018-05-23T03:03:25.323Z","comments":true,"path":"uncategorized/Starting-the-Blog/","link":"","permalink":"http://60yaks.com/uncategorized/Starting-the-Blog/","excerpt":"Finally I started this blog.","text":"Finally I started this blog.60 Yaks per Second is a hobby project making games. This blog will be talking about those games, and any cool tech I feel like writing about along the way.I’m a programmer by trade, so this will probably be a technical blog, where I hope to talk about architecture and ECS design. Unity is my game engine of choice but there may be others mentioned from time to time.","categories":[],"tags":[]}]}